{"attributes":{"kind":"struct","backlinks":[{"tag":"document","title":"Hyperparameter scheduling","docid":"documents/docs/tutorials/hyperparameters.md"},{"tag":"documentation","title":"EarlyStopping","docid":"references/FluxTraining.EarlyStopping"},{"tag":"documentation","title":"testlearner","docid":"references/FluxTraining.testlearner"},{"tag":"document","title":"Getting started","docid":"documents/docs/getting_started.md"},{"tag":"documentation","title":"Callback","docid":"references/FluxTraining.Callback"},{"tag":"documentation","title":"StopOnNaNLoss","docid":"references/FluxTraining.StopOnNaNLoss"},{"tag":"document","title":"Training an image classifier","docid":"documents/docs/tutorials/mnist.ipynb"},{"tag":"document","title":"Callback reference","docid":"documents/docs/callbacks/reference.md"},{"tag":"document","title":"Tips & tricks","docid":"documents/docs/callbacks/tipstricks.md"},{"tag":"document","title":"How to use callbacks","docid":"documents/docs/callbacks/usage.md"},{"tag":"documentation","title":"LogMetrics","docid":"references/FluxTraining.LogMetrics"},{"tag":"document","title":"imagenette_demo","docid":"documents/docs/imagenette_demo.ipynb"},{"tag":"sourcefile","title":"FluxTraining/src/testutils.jl","docid":"sourcefiles/FluxTraining/src/testutils.jl"},{"tag":"sourcefile","title":"FluxTraining/src/learner.jl","docid":"sourcefiles/FluxTraining/src/learner.jl"},{"tag":"sourcefile","title":"FluxTraining/src/FluxTraining.jl","docid":"sourcefiles/FluxTraining/src/FluxTraining.jl"},{"tag":"document","title":"Features","docid":"documents/docs/features.md"},{"tag":"document","title":"FluxTraining.jl","docid":"documents/README.md"},{"tag":"documentation","title":"Metrics","docid":"references/FluxTraining.Metrics"},{"tag":"documentation","title":"MetricsPrinter","docid":"references/FluxTraining.MetricsPrinter"},{"tag":"document","title":"Training loop","docid":"documents/docs/tutorials/training.md"},{"tag":"document","title":"Custom callbacks","docid":"documents/docs/callbacks/custom.md"},{"tag":"document","title":"Data iterators","docid":"documents/docs/background/dataiterator.md"}],"methods":[{"line":15,"file":"/home/runner/.julia/packages/FluxTraining/YVIq2/src/learner.jl","method_id":"FluxTraining.Learner_1","symbol_id":"FluxTraining.Learner","signature":"Learner(model, data::FluxTraining.PropDict, optimizer, lossfn, params, step::FluxTraining.PropDict, callbacks::FluxTraining.Callbacks, cbstate::FluxTraining.PropDict)"},{"line":72,"file":"/home/runner/.julia/packages/FluxTraining/YVIq2/src/learner.jl","method_id":"FluxTraining.Learner_2","symbol_id":"FluxTraining.Learner","signature":"Learner(model, lossfn; callbacks, data, optimizer, kwargs...)"},{"line":80,"file":"/home/runner/.julia/packages/FluxTraining/YVIq2/src/learner.jl","method_id":"FluxTraining.Learner_3","symbol_id":"FluxTraining.Learner","signature":"Learner(model, data, optimizer, lossfn, callbacks::FluxTraining.SafeCallback...; usedefaultcallbacks, cbrunner)"},{"line":15,"file":"/home/runner/.julia/packages/FluxTraining/YVIq2/src/learner.jl","method_id":"FluxTraining.Learner_4","symbol_id":"FluxTraining.Learner","signature":"Learner(model, data, optimizer, lossfn, params, step, callbacks, cbstate)"}],"name":"Learner","title":"Learner","symbol_id":"FluxTraining.Learner","public":true,"module_id":"FluxTraining"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["Learner(model, lossfn; [callbacks = [], optimizer = ADAM(), kwargs...])\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Holds and coordinates all state of the training. ",{"attributes":{},"tag":"code","children":["model"],"type":"node"}," is trained by",{"attributes":{},"tag":"br","children":[],"type":"node"},"optimizing ",{"attributes":{},"tag":"code","children":["lossfn"],"type":"node"}," with ",{"attributes":{},"tag":"code","children":["optimizer"],"type":"node"}," on ",{"attributes":{},"tag":"code","children":["data"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"h2","children":["Arguments"],"type":"node"},{"attributes":{},"tag":"p","children":["Positional arguments:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["model"],"type":"node"},": A Flux.jl model or a ",{"attributes":{},"tag":"code","children":["NamedTuple"],"type":"node"}," of models."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["lossfn"],"type":"node"},": Loss function with signature ",{"attributes":{},"tag":"code","children":["lossfn(model(x), y) -> Number"],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Keyword arguments (optional):"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["data = ()"],"type":"node"},": Data iterators. A 2-tuple will be treated as ",{"attributes":{},"tag":"code","children":["(trainingdataiter, validdataiter)"],"type":"node"},".",{"attributes":{},"tag":"br","children":[],"type":"node"},"You can also pass in an empty tuple ",{"attributes":{},"tag":"code","children":["()"],"type":"node"}," and use the ",{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.epoch!"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["epoch!"],"type":"node"}],"type":"node"}," method with a",{"attributes":{},"tag":"br","children":[],"type":"node"},{"attributes":{},"tag":"code","children":["dataiter"],"type":"node"}," as third argument."],"type":"node"},{"attributes":{},"tag":"p","children":["A data iterator is an iterable over batches. For regular supervised training,",{"attributes":{},"tag":"br","children":[],"type":"node"},"each batch should be a tuple ",{"attributes":{},"tag":"code","children":["(xs, ys)"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["optimizer = ADAM()"],"type":"node"},": The optimizer used to update the ",{"attributes":{},"tag":"code","children":["model"],"type":"node"},"’s weights"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["callbacks = []"],"type":"node"},": A list of callbacks that should be used. If ",{"attributes":{},"tag":"code","children":["usedefaultcallbacks == true"],"type":"node"},",",{"attributes":{},"tag":"br","children":[],"type":"node"},"this will be extended by the default callbacks"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["usedefaultcallbacks = true"],"type":"node"},": Whether to add some basic callbacks. Included",{"attributes":{},"tag":"br","children":[],"type":"node"},"are ",{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.Metrics"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["Metrics"],"type":"node"}],"type":"node"},", ",{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.Recorder"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["Recorder"],"type":"node"}],"type":"node"},", ",{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.ProgressPrinter"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["ProgressPrinter"],"type":"node"}],"type":"node"},",",{"attributes":{},"tag":"br","children":[],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.StopOnNaNLoss"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["StopOnNaNLoss"],"type":"node"}],"type":"node"},", and ",{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.MetricsPrinter"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["MetricsPrinter"],"type":"node"}],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["cbrunner = LinearRunner()"],"type":"node"},": Callback runner to use."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Fields"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"em","children":["(Use this as a reference when implementing callbacks)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["model"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["optimizer"],"type":"node"},", and ",{"attributes":{},"tag":"code","children":["lossfn"],"type":"node"}," are stored as passed in"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["data"],"type":"node"}," is a ",{"attributes":{},"tag":"code","children":["PropDict"],"type":"node"}," of data iterators, usually ",{"attributes":{},"tag":"code","children":[":training"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":[":validation"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["params"],"type":"node"},": An instance of ",{"attributes":{},"tag":"code","children":["model"],"type":"node"},"’s parameters of type ",{"attributes":{},"tag":"code","children":["Flux.Params"],"type":"node"},". If ",{"attributes":{},"tag":"code","children":["model"],"type":"node"}," is",{"attributes":{},"tag":"br","children":[],"type":"node"},"a ",{"attributes":{},"tag":"code","children":["NamedTuple"],"type":"node"},", then ",{"attributes":{},"tag":"code","children":["params"],"type":"node"}," is a ",{"attributes":{},"tag":"code","children":["NamedTuple"],"type":"node"}," as well."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["step::"],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.PropDict"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["PropDict"],"type":"node"}],"type":"node"},": State of the last step. Contents depend on the last run",{"attributes":{},"tag":"br","children":[],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.Phases.Phase"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["Phase"],"type":"node"}],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["cbstate::"],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.PropDict"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["PropDict"],"type":"node"}],"type":"node"},": Special state container that callbacks can",{"attributes":{},"tag":"br","children":[],"type":"node"},"save state to for other callbacks. Its keys depend on what callbacks",{"attributes":{},"tag":"br","children":[],"type":"node"},"are being used. See the ",{"attributes":{"reftype":"document","href":"/documents/docs/callbacks/custom.md","title":"","document_id":"documents/docs/callbacks/custom.md"},"tag":"reference","children":["custom callbacks guide"],"type":"node"},{"attributes":{},"tag":"br","children":[],"type":"node"},"for more info."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"hr","children":[],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["Learner(model, data, optimizer, lossfn, [callbacks...; kwargs...])\n"],"type":"node"}],"type":"node"}],"type":"node"}