{"attributes":{"backlinks":[{"tag":"document","title":"Loss functions","docid":"documents/docs/background/lossfunction.md"},{"tag":"document","title":"Models","docid":"documents/docs/background/model.md"},{"tag":"document","title":"Getting started","docid":"documents/docs/getting_started.md"}],"path":"/home/runner/.julia/packages/FluxTraining/LFydD/docs/background/dataiterator.md","title":"Data iterators"},"tag":"document","children":[{"attributes":{},"tag":"h1","children":[{"mimes":{"text/plain":"Data iterators"}}]},{"attributes":{},"tag":"p","children":[{"mimes":{"text/plain":"A data iterator is an iterator over batches of the data that is used for one step of fitting"}},{"mimes":{"text/plain":"."}},{"mimes":{"text/plain":""}},{"attributes":{},"tag":"br","children":[]},{"mimes":{"text/plain":"You can use different data iterators with this package, as long as they have the following properties"}},{"mimes":{"text/plain":"."}}]},{"attributes":{},"tag":"p","children":[{"mimes":{"text/plain":"Firstly, you must be able to iterate over a data iterator:"}}]},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"CST_DEFINITION","children":[{"attributes":{},"tag":"CST_for","children":[{"attributes":{},"tag":"CST_span","children":[{"attributes":{},"tag":"CST_KEYWORD","children":[{"mimes":{"text/plain":"for"}}]},{"attributes":{},"tag":"CST_whitespace","children":[{"mimes":{"text/plain":" "}}]}]},{"attributes":{},"tag":"CST_OPERATOR","children":[{"attributes":{},"tag":"CST_span","children":[{"attributes":{},"tag":"CST_IDENTIFIER","children":[{"mimes":{"text/plain":"batch"}}]},{"attributes":{},"tag":"CST_whitespace","children":[{"mimes":{"text/plain":" "}}]}]},{"attributes":{},"tag":"CST_OPERATOR","children":[{"mimes":{"text/plain":"in "}}]},{"attributes":{},"tag":"CST_span","children":[{"attributes":{},"tag":"CST_IDENTIFIER","children":[{"mimes":{"text/plain":"dataiter"}}]},{"attributes":{},"tag":"CST_whitespace","children":[{"mimes":{"text/plain":"\n    # step\n"}}]}]}]},{"attributes":{},"tag":"CST_block","children":[{"mimes":{"text/plain":""}}]},{"attributes":{},"tag":"CST_KEYWORD","children":[{"mimes":{"text/plain":"end"}}]}]}]}]},{"attributes":{},"tag":"p","children":[{"mimes":{"text/plain":"The data iterator must also be compatible with the other components of the "}},{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.Learner"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"Learner"}}]}]},{"mimes":{"text/plain":"."}},{"mimes":{"text/plain":" For the standard supervised learning step ("}},{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.TrainingPhase"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"TrainingPhase"}}]}]},{"mimes":{"text/plain":" and "}},{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.ValidationPhase"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"ValidationPhase"}}]}]},{"mimes":{"text/plain":"), this means"}}]},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"batch"}}]},{"mimes":{"text/plain":" is a tuple "}},{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"(xs, ys)"}}]},{"mimes":{"text/plain":" of encoded inputs and targets,"}}]}]},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"xs"}}]},{"mimes":{"text/plain":" is a valid input to the "}},{"attributes":{"reftype":"document","href":"/documents/docs/background/model.md","title":"","document_id":"documents/docs/background/model.md"},"tag":"reference","children":[{"mimes":{"text/plain":"model"}}]},{"mimes":{"text/plain":", so "}},{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"ŷs = model(xs)"}}]},{"mimes":{"text/plain":"; and"}}]}]},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"ys"}}]},{"mimes":{"text/plain":" can be compared to the model output with the "}},{"attributes":{"reftype":"document","href":"/documents/docs/background/lossfunction.md","title":"","document_id":"documents/docs/background/lossfunction.md"},"tag":"reference","children":[{"mimes":{"text/plain":"loss function"}}]},{"mimes":{"text/plain":", i"}},{"mimes":{"text/plain":"."}},{"mimes":{"text/plain":"e"}},{"mimes":{"text/plain":"."}},{"mimes":{"text/plain":" "}},{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"lossfn(ŷs, ys)"}}]}]}]}]},{"attributes":{},"tag":"p","children":[{"mimes":{"text/plain":"If you are working with a "}},{"attributes":{"reftype":"document","href":"/documents/docs/tutorials/training.md","title":"","document_id":"documents/docs/tutorials/training.md"},"tag":"reference","children":[{"mimes":{"text/plain":"custom training loop"}}]},{"mimes":{"text/plain":", you may need to satisfy additional or different properties"}},{"mimes":{"text/plain":"."}}]},{"attributes":{},"tag":"h2","children":[{"mimes":{"text/plain":"Creating data iterators"}}]},{"attributes":{},"tag":"p","children":[{"mimes":{"text/plain":"The simplest data iterator is a vector of preloaded batches"}},{"mimes":{"text/plain":"."}},{"mimes":{"text/plain":" This is what we"}},{"mimes":{"text/plain":"’"}},{"mimes":{"text/plain":"re using in the "}},{"attributes":{"reftype":"document","href":"/documents/docs/tutorials/mnist.ipynb","title":"","document_id":"documents/docs/tutorials/mnist.ipynb"},"tag":"reference","children":[{"mimes":{"text/plain":"MNIST tutorial"}}]},{"mimes":{"text/plain":"."}},{"mimes":{"text/plain":" This is a fine approach for smaller datasets, but has some limitations"}},{"mimes":{"text/plain":"."}}]},{"attributes":{},"tag":"p","children":[{"mimes":{"text/plain":"First of all, there is no principled way for doing things like splitting, subsetting and shuffling data"}},{"mimes":{"text/plain":"."}},{"mimes":{"text/plain":" For this, we recommend using "}},{"attributes":{"href":"https://github.com/JuliaML/MLDataPattern.jl","title":""},"tag":"a","children":[{"mimes":{"text/plain":"MLDataPattern"}},{"mimes":{"text/plain":"."}},{"mimes":{"text/plain":"jl"}}]},{"mimes":{"text/plain":" which provides this functionality and many more utilities for defining and working with datasets"}},{"mimes":{"text/plain":"."}}]},{"attributes":{},"tag":"p","children":[{"mimes":{"text/plain":"Another issue is that of memory load: if the whole dataset is too large to be preloaded in to memory, we have to load individual batches during training"}},{"mimes":{"text/plain":"."}},{"mimes":{"text/plain":" To do this in a way that doesn"}},{"mimes":{"text/plain":"’"}},{"mimes":{"text/plain":"t slow down the training itself, we suggest using "}},{"attributes":{"href":"https://github.com/lorenzoh/DataLoaders.jl","title":""},"tag":"a","children":[{"mimes":{"text/plain":"DataLoaders"}},{"mimes":{"text/plain":"."}},{"mimes":{"text/plain":"jl"}}]},{"mimes":{"text/plain":"."}},{"mimes":{"text/plain":" DataLoaders"}},{"mimes":{"text/plain":"."}},{"mimes":{"text/plain":"jl is compatible with MLDataPattern"}},{"mimes":{"text/plain":"."}},{"mimes":{"text/plain":"jl and allows you to easily create efficient data iterators for out"}},{"mimes":{"text/plain":"-"}},{"mimes":{"text/plain":"of"}},{"mimes":{"text/plain":"-"}},{"mimes":{"text/plain":"memory datasets"}},{"mimes":{"text/plain":"."}},{"mimes":{"text/plain":" The documentation of DataLoaders"}},{"mimes":{"text/plain":"."}},{"mimes":{"text/plain":"jl also has a lot more information on working with large dataset for deep learning"}},{"mimes":{"text/plain":"."}}]}]}