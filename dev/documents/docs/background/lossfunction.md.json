{"attributes":{"backlinks":[{"tag":"document","title":"Getting started","docid":"documents/docs/getting_started.md"},{"tag":"document","title":"Data iterators","docid":"documents/docs/background/dataiterator.md"}],"path":"/home/runner/.julia/packages/FluxTraining/RVSKd/docs/background/lossfunction.md","title":"Loss functions"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["Loss functions"],"type":"node"},{"attributes":{},"tag":"p","children":["A loss function compares model outputs to true targets, resulting in a loss. For a loss function to be compatible with the standard supervised training loop, the following properties must hold."],"type":"node"},{"attributes":{},"tag":"p","children":["Firstly, the loss function should accept the model outputs and targets, and return a single scalar value. Given a ",{"attributes":{"reftype":"document","href":"/documents/docs/background/dataiterator.md","title":"","document_id":"documents/docs/background/dataiterator.md"},"tag":"reference","children":["data iterator"],"type":"node"}," ",{"attributes":{},"tag":"code","children":["dataiter"],"type":"node"}," and a ",{"attributes":{"reftype":"document","href":"/documents/docs/background/model.md","title":"","document_id":"documents/docs/background/model.md"},"tag":"reference","children":["model"],"type":"node"}," ",{"attributes":{},"tag":"code","children":["model"],"type":"node"},":"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"TUPLE","children":[{"attributes":{},"tag":"IDENTIFIER","children":["xs"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["ys"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["dataiter"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["ŷs"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["model"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["xs"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["lossfn"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["ŷs"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["ys"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"ISA","children":["isa"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["Number"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["The loss function must also be differentiable, so that gradients can be calculated during training. See ",{"attributes":{"reftype":"document","href":"/documents/docs/background/model.md","title":"","document_id":"documents/docs/background/model.md"},"tag":"reference","children":["models"],"type":"node"}," for more on how to check this."],"type":"node"},{"attributes":{},"tag":"h2","children":["Creating loss functions"],"type":"node"},{"attributes":{},"tag":"p","children":["Flux.jl comes with a lot of commonly used loss functions built-in in its submodule ",{"attributes":{},"tag":"code","children":["Flux.Losses"],"type":"node"},". See ",{"attributes":{"href":"https://fluxml.ai/Flux.jl/stable/models/losses/","title":""},"tag":"a","children":["Flux.jl loss functions"],"type":"node"}," for a complete reference."],"type":"node"},{"attributes":{},"tag":"p","children":["You can also write your own loss functions. If you are using non-mutating array operations, there is a good chance that it will be differentiable and also be compatible with GPU arrays from ",{"attributes":{"href":"https://github.com/JuliaGPU/CUDA.jl","title":""},"tag":"a","children":["CUDA.jl"],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"}