<HTML><head><title>Custom callbacks</title><link href=../../template/hugobook.css rel=stylesheet ></link><meta content=Type=text/html; charset=utf-8 http-equiv=Content-Type ></meta></head><body><input onclick=toggleMenu() id=menu-control class=hidden toggle type=checkbox ></input><input id=toc-control type=checkbox class=hidden toggle ></input><main class=container flex ><aside id=menu-container class=book-menu ><nav class=book-menu-content ><h2 id=title >FluxTraining.jl</h2><div id=sidebar ><div class=doctree ><body><ul><li><p><a href=../../README.md.html title= >README</a></p></li><li><p><a href=../getting_started.md.html title= >Getting started</a></p></li><li><p><a href=../features.md.html title= >Features</a></p></li><li><p>Tutorials</p><ul><li><p><a href=../tutorials/mnist.ipynb.html title= >Training an image classifier</a></p></li><li><p><a href=../tutorials/hyperparameters.md.html title= >Hyperparameter scheduling</a></p></li><li><p><a href=custom.md.html title= >Writing a custom callback</a></p></li></ul></li><li><p>How to</p><ul><li><p><a href=usage.md.html title= >Use callbacks</a></p></li><li><p><a href=tipstricks.md.html title= >Tips &amp; tricks</a></p></li></ul></li><li><p>Reference</p><ul><li><p><a href=../../REFERENCE.html title= >Docstrings</a></p></li><li><p><a href=../training/basics.md.html title= >Training loop</a></p></li><li><p><a href=reference.md.html title= >Callbacks</a></p></li></ul></li></ul></body></div></div></nav></aside><div class=book-page ><header class=book-header ></header><article><h1 id=custom-callbacks >Custom callbacks</h1><p><em>FluxTraining.jl</em>’s callback system is built around multiple dispatch, so you specify which part of the training you want to “hook into” by dispatching on <a href=../../REFERENCE/FluxTraining.Phases.Phases.Phase.html ><code>FluxTraining.Phases.Phase</code></a>s and <code>Event</code>s. See <a href=../training/basics.md.html title= >Training loop</a> and <a href=../../REFERENCE/FluxTraining.Events.html ><code>FluxTraining.Events</code></a> as a reference to phases and events.</p><h2 id=a-guided-example >A guided example</h2><p>There are 4 things you need to do to implement a custom callback:</p><ul><li><p>Create a callback <code>struct</code> that subtypes <a href=../../REFERENCE/FluxTraining.Callback.html ><code>FluxTraining.Callback</code></a></p></li><li><p>Write event handlers with <a href=../../REFERENCE/FluxTraining.on.html ><code>FluxTraining.on</code></a></p></li><li><p>Define what state the callback accesses by implementing <a href=../../REFERENCE/FluxTraining.stateaccess.html ><code>FluxTraining.stateaccess</code></a></p></li><li><p>(Optionally) define dependencies on other callbacks with <a href=../../REFERENCE/FluxTraining.runafter.html ><code>FluxTraining.runafter</code></a></p></li></ul><p>Let’s go through them one at a time by implementing a simple callback that prints something after every batch.</p><h3 id=callback-struct >Callback <code>struct</code></h3><p>A callback definition has to subtype the abstract <code>Callback</code> type. It can include fields to use as internal state, but we don’t need that here.</p><pre lang=julia ><code>struct Printer &lt;: Callback
end
</code></pre><h3 id=event-handlers >Event handlers</h3><p>Now we need to add an event handler so that <code>Printer</code> can run some code when a batch ends. Event handlers can be defined by adding a method to <code>FluxTraining.on</code>. It takes as arguments an <a href=#events title= >event</a>, a <a href=#phases title= >phase</a>, the callback and the learner:</p><p><code>on(event::Event, phase::Phase, callback::Callback, learner)</code></p><p>The <code>event</code>, <code>phase</code> and <code>callback</code> are used to dispatch.</p><p>In this case, we want to run code at the end of a batch, so the event we need to dispatch on is <a href=../../REFERENCE/FluxTraining.Events.Events.BatchEnd.html ><code>FluxTraining.Events.BatchEnd</code></a>. We want it to run in any phase, so we use the abstract type <code>Phase</code>. The third argument type is the callback we want to add an event handler to. This gives us:</p><pre lang=julia ><code>function FluxTraining.on(
        event::BatchEnd,
        phase::Phase,
        printer::Printer,
        learner)
    println(&quot;Hello, World!&quot;)
end
</code></pre><p>We can now pass an instance of <code>Printer</code> when creating a <code>Learner</code> and the message will be printed at the end of every batch.</p><h3 id=state >State</h3><p>As seen above, the callback handler <code>on</code> receives as the last argument a <code>Learner</code> instance, allowing the callback to access and modify state. If we wanted to print the last batch’s loss instead of a generic message, we could update our definition of <code>on</code>:</p><pre lang=julia ><code>function FluxTraining.on(
        event::EpochEnd,
        phase::Phase,
        printer::Printer,
        learner)
    println(&quot;Step loss:&quot;, learner.batch.loss)
end
</code></pre><p><em>(see <a href=../../REFERENCE/FluxTraining.Learner.html ><code>Learner</code></a> for in-depth documentation of the <code>Learner</code>’s state)</em></p><p>The ability to modify any state is very powerful, but it can quickly become problematic when it is unclear which callbacks modify what state and what the correct order should be.<br></br>Because of that, <em>FluxTraining.jl</em> prevents callbacks from reading and modifying state by default. If we tried to use the above redefinition of <code>on</code>, we would get the following error:</p><pre lang=julia ><code>FluxTraining.ProtectedException(&quot;Read access to Learner.batch.loss disallowed.&quot;)
</code></pre><p>To fix that error, we need to implement <code>stateaccess</code>, a function that specifies what state a callback is allowed to read and write. In our case, we want to read the loss of the current batch:</p><pre lang=julia ><code>FluxTraining.stateaccess(::Printer) = (batch = (loss = Read(),),)
</code></pre><p><em>(see <a href=../../REFERENCE/FluxTraining.stateaccess.html ><code>FluxTraining.stateaccess</code></a> for more information on how to implement it)</em></p><p>After that definition, the above code will run fine. This might seem bothersome, but this extra information makes it possible to analyze state dependencies before any code is run and saves you from running into nasty, hard-to-find bugs that can occur when using many callbacks together.</p><h3 id=dependencies >Dependencies</h3><p>Let’s improve our callback a bit by adding the current step number to the printed message, so it will look like this: <code>&quot;Step 14 loss: 0.0032&quot;</code>. For that we need to know what the current step number is. One way to go about this is to add a field to <code>Printer</code> that starts at <code>0</code> and is incremented every batch.<br></br>Luckily, there already is a callback that tracks this kind of statistics, the <a href=../../REFERENCE/FluxTraining.Recorder.html ><code>Recorder</code></a>. It uses a special piece of state, <code>learner.cbstate</code>, to store a <a href=../../REFERENCE/FluxTraining.History.html ><code>FluxTraining.History</code></a> with this information.</p><div class=admonition ><p><code>learner.cbstate</code> is an object where callbacks can store state that they want to make available to other callbacks. Like any other piece of state, the callback writing to it needs to add a <code>Write()</code> permission to it using <a href=../../REFERENCE/FluxTraining.stateaccess.html ><code>FluxTraining.stateaccess</code></a>.</p><p>What makes <code>cbstate</code> special is that when creating the callback graph, it is checked that every entry in <code>cbstate</code> that is accessed is being created first.</p></div><p>The update to the event handler looks like this:</p><pre lang=julia ><code>function FluxTraining.on(
        event::EpochEnd,
        phase::Phase,
        printer::Printer,
        learner)
    step = learner.cbstate.history[phase].stepsepoch  # steps completed in current epoch
    println(&quot;Step &quot;, , &quot; loss:&quot;, learner.batch.loss)
end
</code></pre><p>We also need to update the definition of <code>stateaccess</code> now:</p><pre lang=julia ><code>FluxTraining.stateaccess(::Printer) = (
    batch = (loss = Read(),),
    cbstate = (history = Read(),),
)
</code></pre><p>Since <code>Printer</code> depends on <code>Recorder</code> now, an error will be thrown if you try to use <code>Printer</code> without <code>Recorder</code>. And that’s it, pass <code>Printer</code> to a <code>Learner</code> and test it out! The upside of jumping through some additional hoops is that using the callback in the wrong context will always result in an error, so the user can have peace of mind.</p><h2 id=conflict-resolution >Conflict resolution</h2><p>When creating a <code>Learner</code>, a dependency graph is created. The graph is then analyzed to find possible conflicts (for example, when two callbacks update the same state). Conflicts are detected automatically and will result in an error. Conflicts happen when the same state is being modified by multiple callbacks and it is unclear which order of running them (if any) is valid.</p><h3 id=resolving-conflicts >Resolving conflicts</h3><p>There are two methods for resolving conflicts, <code>runafter</code> and <code>resolveconflict</code>.<br></br><code>runafter</code> allows you to define list of callbacks that should run before the callback. For example, <code>Recorder</code> needs to run after all metrics:</p><pre lang=julia ><code>FluxTraining.runafter(::Recorder) = (AbstractMetric,)
</code></pre><p><code>resolveconflict</code> provides more granular control to handle a possible conflict between two callbacks. It takes two callbacks and defines how to resolve a conflict:</p><pre lang=julia ><code># the default, errors with a helpful message
resolveconflict(::C1, ::C2) = NotImplemented()    
# two callbacks can never be used together:
resolveconflict(::C1, ::C2) = Unresolvable()      
resolveconflict(::C1, ::C2) = NoConflict()        # there is no conflict, any run order is fine
resolveconflict(cb1::C1, cb2::C2) = RunFirst(cb1) # `cb1` must run before `cb2`.
                                                  # Equivalent to `runafter(::C2) = (C1,)
</code></pre><h2 id=callback-execution >Callback execution</h2><p>By default, a topological ordering of the callbacks is created from the dependency graph and the callbacks are executed serially. This behavior can be overwritten with custom callback executors, for example to create a <em>Dagger.jl</em> node from the graph to allow callbacks to safely run in parallel where valid.</p></article><footer class=book-footer ></footer></div><aside class=book-toc ><nav id=toc class=book-toc-content ><ul><li><a href=#custom-callbacks >Custom callbacks</a><ul><li><a href=#a-guided-example >A guided example</a><ul><li><a href=#callback-struct >Callback struct</a><ul></ul></li><li><a href=#event-handlers >Event handlers</a><ul></ul></li><li><a href=#state >State</a><ul></ul></li><li><a href=#dependencies >Dependencies</a><ul></ul></li></ul></li><li><a href=#conflict-resolution >Conflict resolution</a><ul><li><a href=#resolving-conflicts >Resolving conflicts</a><ul></ul></li></ul></li><li><a href=#callback-execution >Callback execution</a><ul></ul></li></ul></li></ul></nav></aside></main></body></HTML>