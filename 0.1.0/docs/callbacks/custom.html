<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="generator" content="Publish.jl" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="" />
    <title>FluxTraining.jl</title>
    <link rel="stylesheet" href="..&#x2F;..&#x2F;normalize.css" />
    <link rel="stylesheet" href="..&#x2F;..&#x2F;tabulator_simple.min.css" />
    <link rel="stylesheet" href="..&#x2F;..&#x2F;publish.css" />
    <link rel="stylesheet" href="..&#x2F;..&#x2F;default.min.css" />
    <script src="..&#x2F;..&#x2F;versions.js"></script>
    <script src="..&#x2F;..&#x2F;lunr.js"></script>
    <script src="..&#x2F;..&#x2F;highlight.min.js"></script>
    <script src="..&#x2F;..&#x2F;tabulator.min.js"></script>
    <script src="..&#x2F;..&#x2F;julia.min.js"></script>
    <script src="..&#x2F;..&#x2F;julia-repl.min.js"></script>
    <script src="..&#x2F;..&#x2F;publish.js"></script>
    <link rel="stylesheet" href="..&#x2F;custom.css" />
    
</head>
<body>
    <div class="menu">
        <svg id="menu-toggler" title="Contents" onclick="toggleIndexPage();" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 6C2 5.44772 2.44772 5 3 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H3C2.44772 7 2 6.55228 2 6Z" fill="currentColor" /><path d="M2 12.0322C2 11.4799 2.44772 11.0322 3 11.0322H21C21.5523 11.0322 22 11.4799 22 12.0322C22 12.5845 21.5523 13.0322 21 13.0322H3C2.44772 13.0322 2 12.5845 2 12.0322Z" fill="currentColor" /><path d="M3 17.0645C2.44772 17.0645 2 17.5122 2 18.0645C2 18.6167 2.44772 19.0645 3 19.0645H21C21.5523 19.0645 22 18.6167 22 18.0645C22 17.5122 21.5523 17.0645 21 17.0645H3Z" fill="currentColor" /></svg>
        <input id="search-input" placeholder="Search">
        <select id="version-selector"></select>
    </div>
    <main id="page"><article><h1 id="custom-callbacks"><a href="#custom-callbacks" class="anchor"></a>Custom callbacks</h1>
<p><em>FluxTraining.jl</em>’s callback system is built around multiple dispatch, so you specify which part of the training you want to “hook into” by dispatching on <code>Phase</code>s and <code>Event</code>s.</p>
<h2 id="a-guided-example"><a href="#a-guided-example" class="anchor"></a>A guided example</h2>
<p>There are 4 things you need to do to implement a custom callback:</p>
<ol>
<li>Create a callback <code>struct</code> that subtypes <a href="../../docstrings/FluxTraining.Callback.html"><code>Callback</code></a></li>
<li>Write event handlers with <a href="../../docstrings/FluxTraining.on.html"><code>on</code></a></li>
<li>Define what state the callback accesses by implementing <a href="../../docstrings/FluxTraining.stateaccess.html"><code>stateaccess</code></a></li>
<li>(Optionally) define dependencies on other callbacks with <a href="../../docstrings/FluxTraining.runafter.html"><code>runafter</code></a></li>
</ol>
<p>Let’s go through them one at a time by implementing a simple callback that prints something after every batch.</p>
<h3 id="callback-struct"><a href="#callback-struct" class="anchor"></a>1. Callback <code>struct</code></h3>
<p>A callback definition has to subtype the abstract <code>Callback</code> type. It can include fields to use as internal state, but we don’t need that here.</p>
<pre><code class="language-julia">struct Printer &lt;: Callback
end
</code></pre>
<h3 id="event-handlers"><a href="#event-handlers" class="anchor"></a>2. Event handlers</h3>
<p>Now we need to add an event handler so that <code>Printer</code> can run some code when a batch ends.</p>
<p>Event handlers can be defined by adding a method to <code>FluxTraining.on</code>. It takes as arguments an <a href="#events">event</a>, a <a href="#phases">phase</a>, the callback and the learner:</p>
<p><code>on(event::Event, phase::Phase, callback::Callback, learner)</code></p>
<p>The <code>event</code>, <code>phase</code> and <code>callback</code> are used to dispatch.</p>
<p>In this case, we want to run code at the end of a batch, so the event we need to dispatch on is <a href="../../docstrings/FluxTraining.Events.BatchEnd.html"><code>BatchEnd</code></a>. We want it to run in any phase, so we use the abstract type <code>Phase</code>. The third argument type is the callback we want to add an event handler to. This gives us:</p>
<pre><code class="language-julia">function FluxTraining.on(
        event::BatchEnd,
        phase::Phase,
        printer::Printer,
        learner)
    println(&quot;Hello, World!&quot;)
end
</code></pre>
<p>We can now pass an instance of <code>Printer</code> when creating a <code>Learner</code> and the message will be printed at the end of every batch.</p>
<h3 id="state"><a href="#state" class="anchor"></a>3. State</h3>
<p>As seen above, the callback handler <code>on</code> receives as the last argument a <code>Learner</code> instance, allowing the callback to access and modify state.</p>
<p>If we wanted to print the last batch’s loss instead of a generic message, we could update our definition of <code>on</code>:</p>
<pre><code class="language-julia">function FluxTraining.on(
        event::EpochEnd,
        phase::Phase,
        printer::Printer,
        learner)
    println(&quot;Step loss:&quot;, learner.batch.loss)
end
</code></pre>
<p><em>(see <a href="../../docstrings/FluxTraining.Learner.html"><code>Learner</code></a> for in-depth documentation of the <code>Learner</code>’s state)</em></p>
<p>The ability to modify any state is very powerful, but it can quickly become problematic when it is unclear which callbacks modify what state and what the correct order should be.
Because of that, <em>FluxTraining.jl</em> prevents callbacks from reading and modifying state by default. If we tried to use the above redefinition of <code>on</code>, we would get the following error:</p>
<pre><code class="language-julia">FluxTraining.ProtectedException(&quot;Read access to Learner.batch.loss disallowed.&quot;)
</code></pre>
<p>To fix that error, we need to implement <code>stateaccess</code>, a function that specifies what state a callback is allowed to read and write.</p>
<p>In our case, we want to read the loss of the current batch:</p>
<pre><code class="language-julia">FluxTraining.stateaccess(::Printer) = (batch = (loss = Read(),),)
</code></pre>
<p><em>(see <a href="../../docstrings/FluxTraining.stateaccess.html"><code>stateaccess</code></a> for more information on how to implement it)</em></p>
<p>After that definition, the above code will run fine.</p>
<p>This might seem bothersome, but this extra information makes it possible to analyze state dependencies before any code is run and saves you from running into nasty, hard-to-find bugs that can occur when using many callbacks together.</p>
<h3 id="dependencies"><a href="#dependencies" class="anchor"></a>4. Dependencies</h3>
<p>Let’s improve our callback a bit by adding the current step number to the printed message, so it will look like this: <code>&quot;Step 14 loss: 0.0032&quot;</code>.</p>
<p>For that we need to know what the current step number is. One way to go about this is to add a field to <code>Printer</code> that starts at <code>0</code> and is incremented every batch.
Luckily, there already is a callback that tracks this kind of statistics, the <a href="../../docstrings/FluxTraining.Recorder.html"><code>Recorder</code></a>. It uses a special piece of state, <code>learner.cbstate</code>, to store a <a href="../../docstrings/FluxTraining.History.html"><code>History</code></a> with this information.</p>
<div class="admonition info"><p class="admonition-title">Callback state</p>
<p><code>learner.cbstate</code> is a dictionary where callbacks can store state that they want to make available to other callbacks. Like any other piece of state, the callback writing to it needs to add a <code>Write()</code> permission to it using <a href="../../docstrings/FluxTraining.stateaccess.html"><code>stateaccess</code></a>.</p>
<p>What makes <code>cbstate</code> special is that when creating the callback graph, it is checked that every entry in <code>cbstate</code> that is accessed is being created first.</p>
</div>
<p>The update to the event handler looks like this:</p>
<pre><code class="language-julia">function FluxTraining.on(
        event::EpochEnd,
        phase::Phase,
        printer::Printer,
        learner)
    step = learner.cbstate[:history].nstepsepoch  # steps completed in current epoch
    println(&quot;Step &quot;, , &quot; loss:&quot;, learner.batch.loss)
end
</code></pre>
<p>We also need to update the definition of <code>stateaccess</code> now:</p>
<pre><code class="language-julia">FluxTraining.stateaccess(::Printer) = (
    batch = (loss = Read(),),
    cbstate = (history = Read(),),
)
</code></pre>
<p>Since <code>Printer</code> depends on <code>Recorder</code> now, an error will be thrown if you try to use <code>Printer</code> without <code>Recorder</code>.</p>
<p>And that’s it, pass <code>Printer</code> to a <code>Learner</code> and test it out! The upside of jumping through some additional hoops is that using the callback in the wrong context will always result in an error, so the user can have peace of mind.</p>
<h2 id="conflict-resolution"><a href="#conflict-resolution" class="anchor"></a>Conflict resolution</h2>
<p>When creating a <code>Learner</code>, a dependency graph is created. The graph is then analyzed to find possible conflicts (for example, when two callbacks update the same state).
Conflicts are detected automatically and will result in an error. Conflicts happen when the same state is being modified by multiple callbacks and it is unclear which order of running them (if any) is valid.</p>
<h4 id="resolving-conflicts"><a href="#resolving-conflicts" class="anchor"></a>Resolving conflicts</h4>
<p>There are two methods for resolving conflicts, <code>runafter</code> and <code>resolveconflict</code>.
<code>runafter</code> allows you to define list of callbacks that should run before the callback. For example, <code>Recorder</code> needs to run after all metrics:</p>
<pre><code class="language-julia">FluxTraining.runafter(::Recorder) = (AbstractMetric,)
</code></pre>
<p><code>resolveconflict</code> provides more granular control to handle a possible conflict between two callbacks. It takes two callbacks and defines how to resolve a conflict:</p>
<pre><code class="language-julia"># the default, errors with a helpful message
resolveconflict(::C1, ::C2) = NotImplemented()    
# two callbacks can never be used together:
resolveconflict(::C1, ::C2) = Unresolvable()      
resolveconflict(::C1, ::C2) = NoConflict()        # there is no conflict, any run order is fine
resolveconflict(cb1::C1, cb2::C2) = RunFirst(cb1) # `cb1` must run before `cb2`.
                                                  # Equivalent to `runafter(::C2) = (C1,)
</code></pre>
<h4 id="execution"><a href="#execution" class="anchor"></a>Execution</h4>
<p>By default, a a topological ordering of the callbacks is created from the dependency graph and the callbacks are executed serially.
This behavior can be overwritten with custom callback executors, for example to create a <em>Dagger.jl</em> node from the graph to allow callbacks to safely run in parallel where valid.</p>
</article>
        <div id="page-navigation">
            <a id="previous-page" title="Previous" href="reference.html"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16.2426 6.34317L14.8284 4.92896L7.75739 12L14.8285 19.0711L16.2427 17.6569L10.5858 12L16.2426 6.34317Z" fill="currentColor" /></svg></a>
            <a id="next-page" title="Next" href="tipstricks.html"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5858 6.34317L12 4.92896L19.0711 12L12 19.0711L10.5858 17.6569L16.2427 12L10.5858 6.34317Z" fill="currentColor" /></svg></a>
        </div>
    </main>
    <nav id="toc"><p><a href="../../README.html">README</a></p>
<h3 id="start-here"><a href="../../#start-here" class="anchor"></a>Start here</h3>
<ul>
<li><a href="../../docs/getting_started.html">Getting started</a></li>
<li><a href="../../docs/overview.html">User guide</a></li>
<li><a href="../../docs/features.html">Features</a></li>
</ul>
<h3 id="tutorials"><a href="../../#tutorials" class="anchor"></a>Tutorials</h3>
<ul>
<li><a href="../../docs/tutorials/mnist.html">MNIST training</a></li>
</ul>
<h3 id="training-loop"><a href="../../#training-loop" class="anchor"></a>Training loop</h3>
<ul>
<li><a href="../../docs/training/basics.html">Basics</a></li>
</ul>
<h3 id="callbacks"><a href="../../#callbacks" class="anchor"></a>Callbacks</h3>
<ul>
<li><a href="../../docs/callbacks/usage.html">Using callbacks</a></li>
<li><a href="../../docs/callbacks/reference.html">Callback reference</a></li>
<li><a href="../../docs/callbacks/custom.html">Custom callbacks</a></li>
<li><a href="../../docs/callbacks/tipstricks.html">Tips &amp; tricks</a></li>
</ul>
<hr />
<ul>
<li><a href="../../docstrings.html">Docstrings</a></li>
<li><a href="../../docs/status.html">Project status</a></li>
<li><a href="../../docs/ecosystem.html">Ecosystem</a></li>
</ul>
</nav>
    <footer>
        Built with <a target="_blank" href="https://github.com/MichaelHatherly/Publish.jl">Publish.jl</a> and the <a target="_blank" href="https://julialang.org">Julia Language.</a>
    </footer>
    <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
