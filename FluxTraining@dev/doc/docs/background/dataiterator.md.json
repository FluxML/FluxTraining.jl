{"attributes":{"backlinks":[{"tag":"document","title":"Models","docid":"FluxTraining@dev/doc/docs/background/model.md"},{"tag":"document","title":"Getting started","docid":"FluxTraining@dev/doc/docs/getting_started.md"},{"tag":"document","title":"Loss functions","docid":"FluxTraining@dev/doc/docs/background/lossfunction.md"}],"path":"/home/runner/.julia/packages/FluxTraining/HjEA2/docs/background/dataiterator.md","title":"Data iterators"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["Data iterators"],"type":"node"},{"attributes":{},"tag":"p","children":["A data iterator is an iterator over batches of the data that is used for one step of fitting. You can use different data iterators with this package, as long as they have the following properties."],"type":"node"},{"attributes":{},"tag":"p","children":["Firstly, you must be able to iterate over a data iterator:"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"for","children":[{"attributes":{},"tag":"for","children":["for"],"type":"node"},{"attributes":{},"tag":"=","children":[{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"Identifier","children":["batch"],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"in","children":["in"],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"Identifier","children":["dataiter"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"block","children":[{"attributes":{},"tag":"NewlineWs","children":["\n    "],"type":"node"},{"attributes":{},"tag":"Comment","children":["# step"],"type":"node"},{"attributes":{},"tag":"NewlineWs","children":["\n"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"end","children":["end"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["The data iterator must also be compatible with the other components of the ",{"attributes":{"reftype":"symbol","href":"#","title":"","document_id":"FluxTraining@dev/ref/FluxTraining.Learner"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["Learner"],"type":"node"}],"type":"node"},". For the standard supervised learning step (",{"attributes":{"reftype":"symbol","href":"#","title":"","document_id":"FluxTraining@dev/ref/FluxTraining.Phases.TrainingPhase"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["TrainingPhase"],"type":"node"}],"type":"node"}," and ",{"attributes":{"reftype":"symbol","href":"#","title":"","document_id":"FluxTraining@dev/ref/FluxTraining.Phases.ValidationPhase"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["ValidationPhase"],"type":"node"}],"type":"node"},"), this means"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["batch"],"type":"node"}," is a tuple ",{"attributes":{},"tag":"code","children":["(xs, ys)"],"type":"node"}," of encoded inputs and targets,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["xs"],"type":"node"}," is a valid input to the ",{"attributes":{"href":"/doc/docs/background/model.md","title":"","document_id":"FluxTraining@dev/doc/docs/background/model.md"},"tag":"reference","children":["model"],"type":"node"},", so ",{"attributes":{},"tag":"code","children":["ŷs = model(xs)"],"type":"node"},"; and"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["ys"],"type":"node"}," can be compared to the model output with the ",{"attributes":{"href":"/doc/docs/background/lossfunction.md","title":"","document_id":"FluxTraining@dev/doc/docs/background/lossfunction.md"},"tag":"reference","children":["loss function"],"type":"node"},", i.e. ",{"attributes":{},"tag":"code","children":["lossfn(ŷs, ys)"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["If you are working with a ",{"attributes":{"href":"/doc/docs/tutorials/training.md","title":"","document_id":"FluxTraining@dev/doc/docs/tutorials/training.md"},"tag":"reference","children":["custom training loop"],"type":"node"},", you may need to satisfy additional or different properties."],"type":"node"},{"attributes":{},"tag":"h2","children":["Creating data iterators"],"type":"node"},{"attributes":{},"tag":"p","children":["The simplest data iterator is a vector of preloaded batches. This is what we're using in the ",{"attributes":{"href":"/doc/docs/tutorials/mnist.ipynb","title":"","document_id":"FluxTraining@dev/doc/docs/tutorials/mnist.ipynb"},"tag":"reference","children":["MNIST tutorial"],"type":"node"},". This is a fine approach for smaller datasets, but has some limitations."],"type":"node"},{"attributes":{},"tag":"p","children":["First of all, there is no principled way for doing things like splitting, subsetting and shuffling data. For this, we recommend using ",{"attributes":{"href":"https://github.com/JuliaML/MLDataPattern.jl","title":""},"tag":"a","children":["MLDataPattern.jl"],"type":"node"}," which provides this functionality and many more utilities for defining and working with datasets."],"type":"node"},{"attributes":{},"tag":"p","children":["Another issue is that of memory load: if the whole dataset is too large to be preloaded in to memory, we have to load individual batches during training. To do this in a way that doesn't slow down the training itself, we suggest using ",{"attributes":{"href":"https://github.com/lorenzoh/DataLoaders.jl","title":""},"tag":"a","children":["DataLoaders.jl"],"type":"node"},". DataLoaders.jl is compatible with MLDataPattern.jl and allows you to easily create efficient data iterators for out-of-memory datasets. The documentation of DataLoaders.jl also has a lot more information on working with large dataset for deep learning."],"type":"node"}],"type":"node"}],"type":"node"}