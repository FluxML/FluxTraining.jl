{"attributes":{"kind":"struct","backlinks":[{"tag":"document","title":"Tips & tricks","docid":"FluxTraining@dev/doc/docs/callbacks/tipstricks.md"},{"tag":"document","title":"Hyperparameter scheduling","docid":"FluxTraining@dev/doc/docs/tutorials/hyperparameters.md"},{"tag":"document","title":"imagenette_demo","docid":"FluxTraining@dev/doc/docs/imagenette_demo.ipynb"},{"tag":"document","title":"Training loop","docid":"FluxTraining@dev/doc/docs/tutorials/training.md"},{"tag":"documentation","title":"EarlyStopping","docid":"FluxTraining@dev/ref/FluxTraining.EarlyStopping"},{"tag":"document","title":"Callback reference","docid":"FluxTraining@dev/doc/docs/callbacks/reference.md"},{"tag":"document","title":"Features","docid":"FluxTraining@dev/doc/docs/features.md"},{"tag":"documentation","title":"Traces","docid":"FluxTraining@dev/ref/FluxTraining.Traces"},{"tag":"sourcefile","title":"FluxTraining/learner.jl","docid":"FluxTraining@dev/src/learner.jl"},{"tag":"documentation","title":"testlearner","docid":"FluxTraining@dev/ref/FluxTraining.testlearner"},{"tag":"documentation","title":"MetricsPrinter","docid":"FluxTraining@dev/ref/FluxTraining.MetricsPrinter"},{"tag":"document","title":"Custom callbacks","docid":"FluxTraining@dev/doc/docs/callbacks/custom.md"},{"tag":"document","title":"Getting started","docid":"FluxTraining@dev/doc/docs/getting_started.md"},{"tag":"sourcefile","title":"FluxTraining/testutils.jl","docid":"FluxTraining@dev/src/testutils.jl"},{"tag":"document","title":"Data iterators","docid":"FluxTraining@dev/doc/docs/background/dataiterator.md"},{"tag":"document","title":"FluxTraining.jl","docid":"FluxTraining@dev/doc/README.md"},{"tag":"documentation","title":"Callback","docid":"FluxTraining@dev/ref/FluxTraining.Callback"},{"tag":"sourcefile","title":"FluxTraining/FluxTraining.jl","docid":"FluxTraining@dev/src/FluxTraining.jl"},{"tag":"documentation","title":"LogTraces","docid":"FluxTraining@dev/ref/FluxTraining.LogTraces"},{"tag":"documentation","title":"LogMetrics","docid":"FluxTraining@dev/ref/FluxTraining.LogMetrics"},{"tag":"document","title":"Training an image classifier","docid":"FluxTraining@dev/doc/docs/tutorials/mnist.ipynb"},{"tag":"document","title":"How to use callbacks","docid":"FluxTraining@dev/doc/docs/callbacks/usage.md"},{"tag":"documentation","title":"Metrics","docid":"FluxTraining@dev/ref/FluxTraining.Metrics"},{"tag":"documentation","title":"StopOnNaNLoss","docid":"FluxTraining@dev/ref/FluxTraining.StopOnNaNLoss"}],"methods":[{"symbol_id":"FluxTraining.Learner","module_id":"FluxTraining","file":"learner.jl","line":15,"signature":"(::Signature)"},{"symbol_id":"FluxTraining.Learner","module_id":"FluxTraining","file":"learner.jl","line":72,"signature":"(::Signature)"},{"symbol_id":"FluxTraining.Learner","module_id":"FluxTraining","file":"learner.jl","line":81,"signature":"(::Signature)"}],"package_id":"FluxTraining@dev","title":"Learner","symbol_id":"FluxTraining.Learner","exported":true,"module_id":"FluxTraining"},"tag":"documentation","children":[{"attributes":{"symbol":"FluxTraining.Learner","line":28,"module":"FluxTraining","file":"learner.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["Learner(model, lossfn; [callbacks = [], optimizer = ADAM(), kwargs...])\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Holds and coordinates all state of the training. ",{"attributes":{},"tag":"code","children":["model"],"type":"node"}," is trained by optimizing ",{"attributes":{},"tag":"code","children":["lossfn"],"type":"node"}," with ",{"attributes":{},"tag":"code","children":["optimizer"],"type":"node"}," on ",{"attributes":{},"tag":"code","children":["data"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"h2","children":["Arguments"],"type":"node"},{"attributes":{},"tag":"p","children":["Positional arguments:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["model"],"type":"node"},": A Flux.jl model or a ",{"attributes":{},"tag":"code","children":["NamedTuple"],"type":"node"}," of models."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["lossfn"],"type":"node"},": Loss function with signature ",{"attributes":{},"tag":"code","children":["lossfn(model(x), y) -> Number"],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Keyword arguments (optional):"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["data = ()"],"type":"node"},": Data iterators. A 2-tuple will be treated as ",{"attributes":{},"tag":"code","children":["(trainingdataiter, validdataiter)"],"type":"node"},". You can also pass in an empty tuple ",{"attributes":{},"tag":"code","children":["()"],"type":"node"}," and use the ",{"attributes":{"reftype":"symbol","href":"#","title":"","document_id":"FluxTraining@dev/ref/FluxTraining.epoch!"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["epoch!"],"type":"node"}],"type":"node"}," method with a ",{"attributes":{},"tag":"code","children":["dataiter"],"type":"node"}," as third argument."],"type":"node"},{"attributes":{},"tag":"p","children":["A data iterator is an iterable over batches. For regular supervised training, each batch should be a tuple ",{"attributes":{},"tag":"code","children":["(xs, ys)"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["optimizer = ADAM()"],"type":"node"},": The optimizer used to update the ",{"attributes":{},"tag":"code","children":["model"],"type":"node"},"'s weights"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["callbacks = []"],"type":"node"},": A list of callbacks that should be used. If ",{"attributes":{},"tag":"code","children":["usedefaultcallbacks == true"],"type":"node"},", this will be extended by the default callbacks"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["usedefaultcallbacks = true"],"type":"node"},": Whether to add some basic callbacks. Included are ",{"attributes":{"reftype":"symbol","href":"#","title":"","document_id":"FluxTraining@dev/ref/FluxTraining.Metrics"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["Metrics"],"type":"node"}],"type":"node"},", ",{"attributes":{"reftype":"symbol","href":"#","title":"","document_id":"FluxTraining@dev/ref/FluxTraining.Recorder"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["Recorder"],"type":"node"}],"type":"node"},", ",{"attributes":{"reftype":"symbol","href":"#","title":"","document_id":"FluxTraining@dev/ref/FluxTraining.ProgressPrinter"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["ProgressPrinter"],"type":"node"}],"type":"node"},", ",{"attributes":{"reftype":"symbol","href":"#","title":"","document_id":"FluxTraining@dev/ref/FluxTraining.StopOnNaNLoss"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["StopOnNaNLoss"],"type":"node"}],"type":"node"},", and ",{"attributes":{"reftype":"symbol","href":"#","title":"","document_id":"FluxTraining@dev/ref/FluxTraining.MetricsPrinter"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["MetricsPrinter"],"type":"node"}],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["cbrunner = LinearRunner()"],"type":"node"},": Callback runner to use."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Fields"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"em","children":["(Use this as a reference when implementing callbacks)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["model"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["optimizer"],"type":"node"},", and ",{"attributes":{},"tag":"code","children":["lossfn"],"type":"node"}," are stored as passed in"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["data"],"type":"node"}," is a ",{"attributes":{},"tag":"code","children":["PropDict"],"type":"node"}," of data iterators, usually ",{"attributes":{},"tag":"code","children":[":training"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":[":validation"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["params"],"type":"node"},": An instance of ",{"attributes":{},"tag":"code","children":["model"],"type":"node"},"'s parameters of type ",{"attributes":{},"tag":"code","children":["Flux.Params"],"type":"node"},". If ",{"attributes":{},"tag":"code","children":["model"],"type":"node"}," is a ",{"attributes":{},"tag":"code","children":["NamedTuple"],"type":"node"},", then ",{"attributes":{},"tag":"code","children":["params"],"type":"node"}," is a ",{"attributes":{},"tag":"code","children":["NamedTuple"],"type":"node"}," as well."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["step::"],"type":"node"},{"attributes":{"reftype":"symbol","href":"#","title":"","document_id":"FluxTraining@dev/ref/FluxTraining.PropDict"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["PropDict"],"type":"node"}],"type":"node"},": State of the last step. Contents depend on the last run ",{"attributes":{"href":"#","title":""},"tag":"a","children":[{"attributes":{},"tag":"code","children":["Phase"],"type":"node"}],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["cbstate::"],"type":"node"},{"attributes":{"reftype":"symbol","href":"#","title":"","document_id":"FluxTraining@dev/ref/FluxTraining.PropDict"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["PropDict"],"type":"node"}],"type":"node"},": Special state container that callbacks can save state to for other callbacks. Its keys depend on what callbacks are being used. See the ",{"attributes":{"href":"/docs/docs/callbacks/custom.md","title":"","document_id":"FluxTraining@dev/ref/docs/docs/callbacks/custom.md"},"tag":"reference","children":["custom callbacks guide"],"type":"node"}," for more info."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{"symbol":"FluxTraining.Learner","line":78,"module":"FluxTraining","file":"learner.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["Learner(model, data, optimizer, lossfn, [callbacks...; kwargs...])\n"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}