{"attributes":{"backlinks":[{"tag":"document","title":"Getting started","docid":"documents/docs/getting_started.md"},{"tag":"document","title":"Loss functions","docid":"documents/docs/background/lossfunction.md"},{"tag":"document","title":"Models","docid":"documents/docs/background/model.md"}],"path":"/home/runner/.julia/packages/FluxTraining/r5kEx/docs/background/dataiterator.md","title":"Data iterators"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["Data iterators"],"type":"node"},{"attributes":{},"tag":"p","children":["A data iterator is an iterator over batches of the data that is used for one step of fitting.",{"attributes":{},"tag":"br","children":[],"type":"node"},"You can use different data iterators with this package, as long as they have the following properties."],"type":"node"},{"attributes":{},"tag":"p","children":["Firstly, you must be able to iterate over a data iterator:"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"FOR","children":[{"attributes":{},"tag":"FOR","children":["for"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["batch"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IN","children":["in"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["dataiter"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"BLOCK","children":[{"attributes":{},"tag":"NEWLINE_WS","children":["\n    "],"type":"node"},{"attributes":{},"tag":"COMMENT","children":["# step"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"END","children":["end"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["The data iterator must also be compatible with the other components of the ",{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.Learner"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["Learner"],"type":"node"}],"type":"node"},". For the standard supervised learning step (",{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.Phases.TrainingPhase"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["TrainingPhase"],"type":"node"}],"type":"node"}," and ",{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.Phases.ValidationPhase"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["ValidationPhase"],"type":"node"}],"type":"node"},"), this means"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["batch"],"type":"node"}," is a tuple ",{"attributes":{},"tag":"code","children":["(xs, ys)"],"type":"node"}," of encoded inputs and targets,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["xs"],"type":"node"}," is a valid input to the ",{"attributes":{"reftype":"document","href":"/documents/docs/background/model.md","title":"","document_id":"documents/docs/background/model.md"},"tag":"reference","children":["model"],"type":"node"},", so ",{"attributes":{},"tag":"code","children":["ŷs = model(xs)"],"type":"node"},"; and"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["ys"],"type":"node"}," can be compared to the model output with the ",{"attributes":{"reftype":"document","href":"/documents/docs/background/lossfunction.md","title":"","document_id":"documents/docs/background/lossfunction.md"},"tag":"reference","children":["loss function"],"type":"node"},", i.e. ",{"attributes":{},"tag":"code","children":["lossfn(ŷs, ys)"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["If you are working with a ",{"attributes":{"reftype":"document","href":"/documents/docs/tutorials/training.md","title":"","document_id":"documents/docs/tutorials/training.md"},"tag":"reference","children":["custom training loop"],"type":"node"},", you may need to satisfy additional or different properties."],"type":"node"},{"attributes":{},"tag":"h2","children":["Creating data iterators"],"type":"node"},{"attributes":{},"tag":"p","children":["The simplest data iterator is a vector of preloaded batches. This is what we’re using in the ",{"attributes":{"reftype":"document","href":"/documents/docs/tutorials/mnist.ipynb","title":"","document_id":"documents/docs/tutorials/mnist.ipynb"},"tag":"reference","children":["MNIST tutorial"],"type":"node"},". This is a fine approach for smaller datasets, but has some limitations."],"type":"node"},{"attributes":{},"tag":"p","children":["First of all, there is no principled way for doing things like splitting, subsetting and shuffling data. For this, we recommend using ",{"attributes":{"href":"https://github.com/JuliaML/MLDataPattern.jl","title":""},"tag":"a","children":["MLDataPattern",".","jl"],"type":"node"}," which provides this functionality and many more utilities for defining and working with datasets."],"type":"node"},{"attributes":{},"tag":"p","children":["Another issue is that of memory load: if the whole dataset is too large to be preloaded in to memory, we have to load individual batches during training. To do this in a way that doesn’t slow down the training itself, we suggest using ",{"attributes":{"href":"https://github.com/lorenzoh/DataLoaders.jl","title":""},"tag":"a","children":["DataLoaders",".","jl"],"type":"node"},". DataLoaders.jl is compatible with MLDataPattern.jl and allows you to easily create efficient data iterators for out-of-memory datasets. The documentation of DataLoaders.jl also has a lot more information on working with large dataset for deep learning."],"type":"node"}],"type":"node"}],"type":"node"}